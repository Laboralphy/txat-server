/** O2: Fonctionalités Orientées Objets pour Javascript
 * 2010 Raphaël Marandet
 * ver 1.0   10.10.2010
 * ver 1.1   28.04.2013 : ajout d'un support namespace  
 * ver 2.0   25.01.2014 : transformation pour node js 
 * var 2.1   14.02.2014 : classes anonymes
 * ver 3.0   20.02.2015 : changement pour node js : nouvelle facon d'appeler un parent
 * ver 4.0   21.07.2015 : simplification et abandon des namespace pour node js
 */

/** Invoque la methode parente
 * @param This appelant, + Paramètres normaux de la methode parente.
 * @return Retour normal de la methode parente.
 */
function __inheritedCaller() {
	var fCaller = __inheritedCaller.caller;
	var oThis = arguments[0];
	var aParams;
	if ('__inherited' in fCaller) {
		aParams = Array.prototype.slice.call(arguments, 1);
		return fCaller.__inherited.apply(oThis, aParams);
	} else {
		throw new Error('o2: no __inherited');
	}
}

/** Creation d'une nouvelle classe
 * @example NouvelleClasse = Function.createClass(function(param1) { this.data = param1; });
 * @param fConstructor prototype du constructeur
 * @return Function
 */
function createClass(pPrototype) {
	if (arguments.length > 1) {
		throw new Error('o2: too much arguments');
	}
	var f;
	f = function() {
		if ('__construct' in this) {
			this.__construct.apply(this, arguments);
		}
	};
	if (pPrototype === undefined) {
		return f;
	} else if (typeof pPrototype === 'object') {
		return extendPrototype(f, pPrototype);
	} else {
		return null;
	}
};


/** Mécanisme d'extention de classe.
 * Cette fonction accepte un ou deux paramètres
 * Appel avec 1 paramètre :
 * @param Définition de prototype à ajouter à la classe.
 * Appel avec 2 paramètres :
 * @param Classe parente
 * @param Définition de prototype à ajouter à la classe.
 * @return Instance de lui-même.
 */
function extendPrototype(pParent, aDefinition) {
	var iProp = '', f, fInherited;
	if (aDefinition instanceof Function) {
		aDefinition = aDefinition.prototype;
	}
	for (iProp in aDefinition) {
		f = aDefinition[iProp];
		if (iProp in pParent.prototype && (pParent.prototype[iProp] instanceof Function)) {
			// Sauvegarde de la méthode en cours : elle pourrait être héritée
			fInherited = pParent.prototype[iProp];
			// La méthode en cour est déja présente dans la super classe
			if (f instanceof Function) {
				// completion des __inherited
				pParent.prototype[iProp] = f;
				pParent.prototype[iProp].__inherited = fInherited;
			} else {
				// On écrase probablement une methode par une propriété : Erreur
				throw new Error('o2: method ' + iProp + ' overridden by property.');
			}
		} else {
			// Ecrasement de la propriété
			pParent.prototype[iProp] = aDefinition[iProp];
		}
	}
	return pParent;
};

/** Mécanisme d'extension de classe
 * @param Parent Nom de la classe Parente
 * @param X prototype du constructeur (optionnel)
 * @param Y prototype de la classe étendue
 */
function extendClass(Parent, X) {
	if (arguments.length > 2) {
		throw new Error('o2: too much arguments');
	}
	return extendPrototype(extendPrototype(createClass(), Parent), X);
};

module.exports = {
	parent: __inheritedCaller,
	createClass: createClass,
	extendClass: extendClass
};
