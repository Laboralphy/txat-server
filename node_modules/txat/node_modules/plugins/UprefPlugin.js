var O2 = require('o2');
var Mediator = require('mediator');
var fs = require('fs');
var Q = require('q');

var UPREF_STORAGE = 'upref.storage';

var UprefPlugin = O2.extendClass(Mediator.Plugin, {
	
	getName: function() {
		return 'Upref';
	},
	
	init: function() {
		this.register('config');
		this.register('userConnected');
		this.register('userPref');
		try {
			fs.statSync(UPREF_STORAGE);
		} catch (e) {
			fs.mkdirSync(UPREF_STORAGE);
		}
	},
	
	config: function(oConfig) {
		var c = oConfig[this.getName()];
	},
	
	userConnected: function(oUser) {
		// tout en SYNCHRONE !
		// on ne laissera pas le user sans ses données
		var sDirectory = UPREF_STORAGE + '/' + oUser.getName();
		try {
			var oStat = fs.statSync(sDirectory);
			var aFiles = fs.readdirSync(sDirectory);
			this.sendSignal('log', 'loading upref:', aFiles.join(', '));
			aFiles.forEach(function(f) {
				var sContent = fs.readFileSync(sDirectory + '/' + f);
				oUser.setData(f, sContent.toString());
			}, this);
		} catch(e) {
			this.sendSignal('log', sDirectory + ' : not found');
			fs.mkdirSync(sDirectory);
			// probablement pas de données disponible
			// quitter sans raler
		}
	},

	userPref: function(oUser, sVariable, sValue) {
		// ici on peut faire du asynchrone
		var sDirectory = UPREF_STORAGE + '/' + oUser.getName();
		var qStat = Q.nbind(fs.stat);
		var qWriteFile = Q.nbind(fs.writeFile);
		var qMkDir = Q.nbind(fs.mkdir);
		function doWrite() {
			return qWriteFile(sDirectory + '/' + sVariable, sValue);
		}
		function doError(err) {
			return qMkDir(sDirectory).then(doWrite);
		}
		qStat(sDirectory).then(doWrite, doError);
	}
});

module.exports = UprefPlugin;
